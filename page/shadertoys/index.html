<!DOCTYPE html>
<html>

  <head>

    <title>Leon Denise</title>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="/style/style.css" />
    <link rel="stylesheet" href="/style/grid.css" />
    <link rel="stylesheet" href="/style/responsive.css" />

    <script src="/script/lib/twgl-full.min.js"></script>
    <script src="/script/lib/virtual-webgl2.js"></script>
    <script type="module" src="/script/shader-view.js" defer></script>

</head>

  <body>

    
<div class="nav">

    <div class="name"><a href="/about/">Leon Denise</a></div>
    
    <div class="buttons">
        <a href="/"><img class="button" src="/media/icon/function_24dp_E8EAED_FILL0_wght400_GRAD0_opsz24.svg"></a>
        <a href="/gifs/"><img class="button" src="/media/icon/experiment_24dp_E8EAED_FILL0_wght400_GRAD0_opsz24.svg"></a>
    </div>

</div>

<style>

    .nav 
    {
        position: absolute;
        font-size: 20px;
        text-align: center;
        left: 50%;
        transform: translate(-50%,0);
        top: 0;
    }

    .name
    {
        line-height: var(--navigation-size);
    }

    .buttons img
    {
        vertical-align: middle;
    }

    .nav div
    {
        display: inline-block;
    }

    .nav a:hover
    {
        filter: drop-shadow(0 0 5px white);
    }

</style>

    <div class="grid-3">
  
  <shadertoy-view id="High Voltage Tendencies">
    
    <div 
    id="Image"
    
    ichannel0="/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
    
    >
// High Voltage Tendencies
// Another cloud shader

// reduces if too slow
const float frames = 3.;

// global
float glow;

// snippets
#define R iResolution.xy
#define N(a,b,c) normalize(vec3(a,b,c))
#define ss(a,b,t) smoothstep(a,b,t)
mat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }
float gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }

// noise
float fbm (vec3 seed)
{
    float result = 0., a = .5;
    for (int i = 0; i < 8; ++i, a/=2.)
    {
        result += abs(gyroid(seed/a))*a;
    }
    return result;
}

// signed distance function
float map(vec3 p)
{
    float dist = 100.;
    
    // cloud
    vec3 seed = p*.4;
    seed.z += iTime*.1;
    float noise = fbm(seed);
    dist = length(p) - .5 - noise*1.;
    
    // lightning
    const float count = 4.;
    float a = 1.;
    float t = iTime*.2 + noise*.5;
    float r = .1+.2*sin(iTime+p.x);
    float shape = 100.;
    for (float i = 0.; i < count; ++i)
    {
        p.xz *= rot(t/a);
        p.xy *= rot(t/a);
        p = abs(p)-r*a;
        shape = min(shape, length(p.xz));
        a /= 1.8;
    }
    glow += .002/shape;
    dist = min(dist, shape);
    
    return dist*.8;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;
    vec3 color = vec3(0);
    
    // layers
    for (float f = 0.; f < frames; ++f)
    {
        // blue noise scroll by iq https://www.shadertoy.com/view/tlySzR
        ivec2 p = ivec2(fragCoord);
        p = (p+(iFrame*196+int(f))*ivec2(113,127)) & 1023;
        vec3 blu = texelFetch(iChannel0,p,0).xyz;

        // coordinates
        vec3 pos = vec3(0,0,7);
        vec3 ray = normalize(vec3(uv,-3));
        ray.xy += blu.xy * ss(.5,8.,length(uv)); // blur edge
        pos += ray * blu.z * 4.; // pre start

        vec3 tint = vec3(0);
        glow = 0.;

        // raymarch
        const float count = 40.;
        float maxDist = 10.;
        float steps = 0.;
        float total = 0.;
        for (steps = count; steps > 0.; --steps) {
            float dist = map(pos);
            if (dist < .001*total || total > maxDist) break;
            dist *= 0.9+0.1*blu.z; // dithering
            ray.xy += blu.xy*total*.001; // depth of field
            pos += ray * dist;
            total += dist;
        }

        // shading
        float shade = steps/count;
        if (shade > .1 && total < maxDist) {

            // NuSan https://www.shadertoy.com/view/3sBGzV
            vec2 noff = vec2(.2*pow(length(uv),2.),0);
            vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));

            // color palette https://iquilezles.org/www/articles/palettes/palettes.htm
            tint = .8+.5*cos(vec3(1,2,3)*6.1 + pos.y*1. + normal.z*3.);

            // backlight
            tint *= dot(normal, ray)*.5+.5;
        }

        // bloom
        tint += glow*.5;
        
        // average
        color += tint/frames;
    }
    
    fragColor = vec4(color, 1);
}</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Inercia Royaliptic">
    
    <div 
    id="Image"
    
    ichannel0="https://soundcloud.com/diffty/dj-set-dnb-footwork-eclipse-sur-la-canopee-2017-06-03"
    
    >
// Some bouncing made for Inercia Shader Royale 2022
// https://2022.inercia.pt/
// music by Diffty https://soundcloud.com/diffty

// globals
float fft, material, rnd;

// toolbox
#define time iTime
#define ss(a,b,t) smoothstep(a,b,t)
mat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }
float gyroid (vec3 p) { return dot(sin(p), cos(p.yzx)); }
float random (vec2 p) { return fract(sin(dot(p,vec2(10.1324,5.654)))*46501.654); } 
float fbm (vec3 p) {
  float result = 0., a = .5;
  for (float i = 0.; i < 3.; ++i) {
    result += abs(gyroid(p/a)*a);
    a /= 2.;
  }
  return result;
}
float box (vec3 p, vec3 s) {
  vec3 b = abs(p)-s;
  return max(b.x,max(b.y,b.z));
}

float map(vec3 p)
{
  float dist = 100.;
  
  // rotation angle
  float t = time*1.+p.z*.5;
  t = pow(fract(t), 10.) + floor(t);
  t += rnd;
  
  // translate offset
  float tt = time + p.z;
  tt = pow(fract(tt), 10.) + floor(tt);
  float r = .0*fft+.2+.1*sin(length(p)*3.-tt+p.z*5.);
  
  // kaleido
  float a = 1.;
  const float count = 12.;
  for (float i = 0.; i < count; ++i) {
    p.xz *= rot(t/a);
    p.yz *= rot(sin(t)/a);
    p.x = abs(p.x)-r*a;
    float shape = length(p)-.1*a;
    //if (mod(i, 2.) < .5) shape = box(p,vec3(1,1,.01)*.15*a);
    material = shape < dist ? i : material;
    dist = min(dist, shape);
    a /= 1.2;
  }
  
  // extra details surface
  float noise = fbm(p*60.);
  dist -= noise*.002;
  
  return dist*.3;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // coordinates
    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;
    vec3 pos = vec3(0,0,2);
    vec3 ray = normalize(vec3(uv, -3));
    
    // noise
    float rng = random(uv);
    vec2 jitter = vec2(random(uv+.196),random(uv+4.1));
    
    // audio
    fft = texture(iChannel0, vec2(0.)).r;
    fft = pow(fft, .8);
    float aa = abs(atan(uv.y, uv.x))/10.+fft*3.;
    float lod = 100.;
    aa = floor(aa*lod)/lod;
    float fft2 = texture(iChannel0, vec2(fract(aa),0)).r;
    
    // timeline random (used in map to add extra rotation)
    float t = time*2.;
    float index = floor(t);
    float anim = fract(t);
    rnd = mix(random(vec2(index)), random(vec2(index+1.)), anim);
    
    // blur edge
    float luv = length(uv);
    ray.xy += jitter * smoothstep(.5, 2., luv)*.1;
    
    // glitch blur
    vec2 llod = 10.*vec2(random(vec2(floor(time*4.+.5))), random(vec2(floor(time*2.))));
    float blur = random(floor(uv*llod)+floor(time*4.));
    ray.xy += jitter*step(.95, blur)*.1;
    
    // raymarch
    const float count = 100.;
    float shade = 0.;
    float total = 0.;
    for (float index = count; index > 0.; --index) {
        float dist = map(pos);
        if (dist < .0001 * total || total > 10.) {
            shade = index/count;
            break;
        }
        // blur in distance
        ray.xy += jitter*total*.0005;
        dist *= .9+.1*rng;
        total += dist;
        pos += ray * dist;
    }
    
    // background
    vec3 color = vec3(0);
    color += ss(4.,.5, luv)*.5;
    
    // circle fft
    luv = length(uv);
    color += ss(.01,.0,abs(abs(luv-fft))-fft2*.2);
    
    // shading
    if (total < 10. && shade > .0) {
        color = vec3(0.2);
        vec2 unit = vec2(.001,0);
        vec3 normal = normalize(vec3(map(pos+unit.xyy)-map(pos-unit.xyy), map(pos+unit.yxy)-map(pos-unit.yxy), map(pos+unit.yyx)-map(pos-unit.yyx)));
        vec3 rf = reflect(ray, normal);
        color += .5+.5*cos(vec3(1,2,3)*5.+pos.z+blur);
        color *= mod(material, 2.);
        color += pow(dot(ray, normal)*.5+.5, 1.) * 2.;
        color += pow(dot(rf, vec3(0,1,0))*.5+.5, 10.);
        color *= shade;
    }
    
    fragColor = vec4(color, 1);
}</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Particles Party">
    
    <div 
    id="Image"
    
    ichannel0="/media/previz/buffer00.png"
    
    ichannel1="/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
    
    >
// Particles Party

// simple colorful particles system
// will try voronoi tracking next time

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec3 color = vec3(0);
    
    // coordinates
    vec2 uv = fragCoord/iResolution.xy;
    float rng = texture(iChannel1, fragCoord/1024.).r;
    vec2 aspect = vec2(iResolution.y/iResolution.x, 1.);
    
    // data
    vec4 data = texture(iChannel0, uv);
    float shade = data.r;
    float mat = data.g;
    
    // rainbow
    color = .5+.5*cos(vec3(1,2,3)*4.9 + mat);
    
    // light
    vec3 un = vec3(0.005*aspect, 0);
    #define T(un) texture(iChannel0, uv+un).r
    vec3 normal = normalize(vec3(T(un.xz)-T(-un.xz),T(un.zy)-T(-un.zy), .5));
    float d = dot(normal, normalize(vec3(0,-2,1)))*.5+.5;
    color += pow(d, 10.);
    
    // shadow
    color *= smoothstep(.0,.01,shade);

    fragColor = vec4(color, 1);
}</div>
    
    <div 
    id="Buffer A"
    
    ichannel0="/media/previz/buffer00.png"
    
    ichannel1="/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
    
    >
const float count = 100.;

float speed = .3;
float friction = 3.;
float fade = 0.1;
float thin = 0.02;

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // coordinates
    vec2 uv = fragCoord/iResolution.xy;
    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;
    
    // buffer
    vec4 frame = texture(iChannel0, uv);
    
    // pixels are data (bottom left)
    if (fragCoord.y < 1. && fragCoord.x < count)
    {
        float id = fragCoord.x;
            
        // init
        if (iFrame < 1)
        {
            // random position and velocity
            frame = vec4(hash41(id)*2.-1.);
            frame.zw *= .01;
        }
        else
        {
            // coordinates
            vec2 aspect = vec2(iResolution.x/iResolution.y, 1.);
            vec2 p = frame.xy;
            vec2 offset = vec2(0);
            vec2 target = vec2(0);
            
            // respawn
            float t = iTime * 10.;
            float idd = id+floor(t) * count;
            if (hash11(idd) > .95 && fract(t) < .1)
            {
                frame = hash41(idd)*2.-1.;
                frame.xy *= aspect;
                frame.zw *= .01;
                fragColor = frame;
                return;
            }
            
            // interaction
            if (iMouse.z > 0.)
            {
                target = (2.*iMouse.xy-iResolution.xy)/iResolution.y;
            }
            
            // curl
            float noise = fbm(vec3(p, length(p) + iTime));
            float a = noise * 6.28;
            offset += vec2(cos(a), sin(a));
            
            // target
            offset += normalize(target.xy-p) * 2. * length(target.xy-p);
            
            // jitter
            offset += (hash21(id)*2.-1.)*(.5+.5*sin(iTime));
            
            // inertia
            vec2 velocity = frame.zw;
            velocity = velocity * (1.-friction*iTimeDelta) + offset * speed * iTimeDelta;
            
            // apply
            frame.xy += velocity;
            frame.zw = velocity;
        }
    }
    
    // pixels are colors
    else
    {
        float matID = 0.;
        float dist = 100.;
        float dither = texture(iChannel1, fragCoord/1024.).r;

        for (float i = 0.; i < count; ++i)
        {
            // iterate pixel data
            vec4 data = texelFetch(iChannel0, ivec2(i,0), 0);
            
            // circle shape (jitter blending with previous pos)
            vec2 pos = data.xy - data.zw * dither;
            float shape = length(pos-p);
            matID = shape < dist ? i : matID;
            dist = min(dist, shape);
        }

        // grayscale
        float shade = smoothstep(thin,.0,dist);

        // buffer
        frame.r = max(frame.r - fade, shade);
        
        // material layer
        if (dist < thin) frame.g = matID;
    }
    
    fragColor = frame;
}</div>
    
    <div 
    id="Common"
    
    >
float gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }
float fbm (vec3 seed)
{
    float result = 0., a = .5;
    for (int i = 0; i < 3; ++i, a/=2.)
    {
        result += (gyroid(seed/a))*a;
    }
    return result;
}

// Dave Hoskins https://www.shadertoy.com/view/4djSRW
float hash11(float p)
{
    p = fract(p * .1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}
vec2 hash21(float p)
{
	vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);

}
vec4 hash41(float p)
{
	vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);
}</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Hellscape Airline">
    
    <div 
    id="Image"
    
    ichannel0="/media/previz/buffer00.png"
    
    >

// Hellscape Airline by Leon Denise
// an abundance of noise patterns
// using code from Inigo Quilez, Antoine Zanuttini, Dave Hoskins
// and many more


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord.xy / iResolution.xy;
    fragColor = texture(iChannel0, uv);
}
</div>
    
    <div 
    id="Common"
    
    >
// globals
float material;

#define ss(a,b,t) smoothstep(a,b,t)
mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }
float gyroid (vec3 s) { return dot(sin(s),cos(s.yzx)); }

// Dave Hoskins
// https://www.shadertoy.com/view/4djSRW
float hash13(vec3 p3)
{
	p3  = fract(p3 * .1031);
    p3 += dot(p3, p3.zyx + 31.32);
    return fract((p3.x + p3.y) * p3.z);
}
vec3 hash33(vec3 p3)
{
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return fract((p3.xxy + p3.yxx)*p3.zyx);
}</div>
    
    <div 
    id="Buffer A"
    
    ichannel0="/media/previz/buffer00.png"
    
    >

// Hellscape Airline by Leon Denise
// an abundance of noise patterns
// using code from Inigo Quilez, Antoine Zanuttini, Dave Hoskins
// and many more


// gyroid flavoured FBMs
float fbmCloud (vec3 p) {
    p.z *= .3;
    float result = 0., a = 0.5;
    for (float i = 0.; i < 8.; ++i, a /= 2.) {
        p.z -= iTime * .1;
        result += abs(gyroid(p/a))*a; }
    return result;
}

float fbmGround (vec3 p) {
    float result = 0., a = 0.5;
    for (float i = 0.; i < 8.; ++i, a /= 2.) {
        p.z += result * .5 + iTime * .001;
        result += gyroid(p/a)*a; }
    return result;
}

float fbmHorizon (vec3 p) {
    float result = 0., a = 0.5;
    for (float i = 0.; i < 3.; ++i, a /= 2.) {
        p.z += result * .5 - iTime*.2;
        result += abs(gyroid(p/a))*a; }
    return result;
}

float map(vec3 p)
{
    float d = 100.;
    vec3 seed = p * .5;
    
    // traveling
    seed.z -= iTime * .1;
    
    // shapes
    float ground = p.y+1.-fbmGround(seed);
    float cloud = -p.y+2.5-fbmCloud(seed*.5);
    
    material = ground < cloud ? 0. : 1.;
    return min(ground, cloud);
}

// Inigo Quilez
// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf
float getAO(vec3 p, vec3 n, float scale, float intensity)
{
    float ao = 0.;
    for (float i = 1.; i <= 4.; ++i)
        ao += (i*scale-map(p + n * i * scale));
    return clamp(1.-ao*intensity, 0., 1.);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec3 color = vec3(0);
    
    // pixels positions
    vec2 p = (fragCoord.xy-iResolution.xy/2.) / iResolution.y;
    vec2 uv = fragCoord.xy / iResolution.xy;
    
    // noises
    vec3 seed = vec3(fragCoord.xy, iFrame);
    float rng = hash13(seed);
    vec3 blur = hash33(seed)*2.-1.;
    
    // coordinates
    vec3 pos = vec3(-1,0,4);
    float fov = .2 * sin(iTime*.2);
    vec3 ray = normalize(vec3(p, -0.8+fov));
    
    // camera look
    vec2 angle = vec2(
        sin(-iTime*.05)*.4,
        sin(-iTime*.1)*.15-.08);
        
    // mouse look
    if (iMouse.z > 0.)
        angle = (iMouse.xy-iResolution.xy/2.)/iResolution.y;
        
    ray.yz *= rot(angle.y);
    ray.xz *= rot(angle.x);
    
    // start ahead
    pos += ray * rng;
    
    // blur edge
    pos += blur * ss(0.5,1.,length(p)) * .02;
    
    // raymarch
    float shade = 0.;
    float total = 0.;
    float maxDist = 30.;
    const float count = 60.;
    for (float index = count; index > 0.; --index)
    {
        float dist = map(pos);
        if (dist < .001 || total > maxDist)
        {
            shade = index/count;
            break;
        }
        dist *= 0.9 + 0.1 * rng;
        total += dist;
        ray += blur*.0005;
        pos += ray * dist;
    }
    
    // coloring
    if (shade > 0.1 && total < maxDist)
    {
        float mat = material;
        
        // NuSan
        // https://www.shadertoy.com/view/3sBGzV
        vec2 e = vec2(0.01,0);
        vec3 normal = normalize(map(pos)-vec3(map(pos-e.xyy),map(pos-e.yxy),map(pos-e.yyx)));
        vec3 rf = reflect(ray, normal);
        
        // ground
        if (mat == 0.)
        {
            // Inigo Quilez
            // https://iquilezles.org/articles/palettes
            color = .5+.5*cos(vec3(1,2,3)*5.8-pos.y*2.-4.+rf.z);
            color.gb *= getAO(pos, normal, .05, 2.);
            color *= shade;
        }
        // cloud
        else
        {
            color = .5+.5*cos(vec3(1,2,3)*5.8+pos.y*2.-0.0-rf.y*1.);
        }
    }
    // horizon
    else if (total > maxDist)
    {
        float noise = fbmHorizon(vec3(pos)*0.4);
        color = .5+.5*cos(vec3(1,2,3)*5.5-noise*2.+abs(ray.y)*12.);
        color *= ss(.1,-.1,abs(ray.y));
    }

    // smooth frame
    color = mix(color, texture(iChannel0, uv).rgb, .9);
    
    fragColor = vec4(color, 1);
}
</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Frooty">
    
    <div 
    id="Image"
    
    ichannel0="/media/previz/buffer00.png"
    
    ichannel1="/media/previz/buffer01.png"
    
    >
// Frooty by Leon Denise 2023-01-16

// a floral iteration over 
// Baroque Fractal Pattern https://www.shadertoy.com/view/flcBD4
// Taste of Noise 7 https://www.shadertoy.com/view/NddSWs

// Buffer A draws shape trails with a depth and id buffer
// Buffer B calculates ambient occlusion and normal
// Image does the coloring and lighting

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec3 color = vec3(0);
    
    // 2d coordinates
    vec2 uv = fragCoord/iResolution.xy;
    vec2 p = (fragCoord-R.xy/2.)/R.y;
    
    // pixel data from Buffer A (steps, timeline, id, depth)
    vec4 data = texture(iChannel0, uv);
    float total = data.a;
    
    if (total > .001 && total < max_dist)
    {
        // data from Buffer A
        float shade = data.r;
        float time = data.g;
        float mat = floor(data.b);
        float froot = fract(data.b);
        
        // data from Buffer B (normal, ao)
        data = texture(iChannel1, uv);
        vec3 normal = data.xyz;
        float ao = data.a;
        
        // palettes
        // Inigo Quilez https://iquilezles.org/articles/palettes
        vec3 tintCold = .5+.5*cos(vec3(2,3,1)*5.7+4.-time*4.);
        vec3 tintWarm = .5+.5*cos(vec3(1,2,3)*4.9+mat*1.+uv.y*2.+5.);
        color = mix(tintCold, tintWarm, froot);
        
        // lighting
        color += pow(dot(normal, N(0,1,1))*.5+.5, 4.)*froot;
        //color += .2*(1.-pow(abs(dot(normal, N(0,0,1))), .5));
        
        // shadow
        color *= shade;
        color *= ao * .5 + .5;
        color *= ss(100.,0.,total);
    }
    else
    {
        // background
        color = vec3(0.039,0.110,0.322) * smoothstep(2., -2., length(uv-.5));
    }
    
    // fade transition
    float t = fract(iTime/delay);
    color *= ss(.0,.1,t) * ss(1.,.9,t);
    
    // vignette
    color *= ss(1.5, .5, length(p));
    
    fragColor = vec4(color, 1);
}</div>
    
    <div 
    id="Buffer A"
    
    ichannel0="/media/previz/buffer00.png"
    
    ichannel1="/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
    
    >
// Frooty by Leon Denise 2023-01-16

// this frame buffer draws the depth buffer with pixel data (steps, timeline, id, depth)
// it draws shape only if it is closer that previous depth
// we can then draw trails of shapes and relight later in Buffer B


// globals
float timeline;
float id, froot;

float map(vec3 p)
{
    vec3 q = p;
    float dist = 100.;
    float shape = 100.;
    
    // grid repeat
    float cell = 5.;
    vec3 pp = p+cell/2.;
    id = hash13(floor(pp/cell));
    p = repeat(pp, cell);
    p += (hash31(floor(id*100.))*2.-1.)*cell/4.;
    
    // timing
    float t = timeline;
    float tt = fract(t);
    float end = mix(.2,.8,id);
    float anim = ss(-.1,end,tt);
    
    // shape parameters
    float r = 1.; // range 
    float f = 1.7; // falloff coeficient
    const float count = 6.; // iterations
    
    // angle
    float n = id*1000.+anim*2. + floor(t); 
    
    // going outter
    r *= pow(ss(0.01,end,tt), .2);
    
    // kaleidoscopic iterated function
    float a = 1.;
    for (float i = 0.; i < count; ++i)
    {
        // twist faster and faster
        p.xy *= rot(n/a);
        p.yz *= rot(n/a);
        
        // fold
        p.x = abs(p.x)-r*a;
        
        // falloff
        a /= f;
    }
    
    // tube (the stems)
    dist = min(dist, max(abs(p.y)-.1*(1.-anim), length(p.xz)-.02));
    
    // sphere (the froots)
    froot = ss(end-.3,end,tt);
    float size = .1 * froot - (1.-froot) * .1;
    dist = min(dist, length(p)-size);
    
    // crop shell to avoid camera collision
    dist = max(dist, -length(q)+cell/2.);
    
    return dist * .8;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // 2d coordinates
    vec2 uv = fragCoord/R.xy;
    vec2 p = (fragCoord-R.xy/2.)/R.y;
    
    // noise
    vec3 rng = hash(uvec3(fragCoord, iFrame));
    vec3 blu = texture(iChannel1, fragCoord/1024.).rgb;
    vec2 blur = normalize(blu.xy*2.-1.) * blu.z;
    
    // buffer
    vec4 frame = texture(iChannel0, uv);
    
    // timeline used by map for animation
    timeline = rng.x*.001+iTime/delay;

    // 3d coordinates
    vec3 pos = vec3(0,0,0);
    vec3 ray = normalize(vec3(p, -2.));
    vec2 angle = (hash21(floor(iTime/delay))*2.-1.)*.5;
    ray.yz *= rot(angle.x);
    ray.xz *= rot(angle.y);
    
    // raymarch
    float total = 0.;
    float steps = 0.;
    float dof = 0.;
    const float count = 80.;
    for (steps = count; steps > 0.; --steps) {
        float dist = map(pos);
        if (dist < .001 || total > max_dist) break;
        
        // dithering
        dist *= 0.9 + 0.1 * rng.z;
        
        // dof far blur
        dof += 0.0001 * ss(15.,30.,total);
        ray.xy += blur * dof;
        
        total += dist;
        pos += ray * dist;
    }

    // draw if closer
    float depth = frame.a;
    bool closer = total < depth || depth < .001;
    if (total < max_dist && closer)
    {
        // data pack
        fragColor = vec4(
            steps/count, // used to apply shadow
            fract(timeline), // used to offset tint
            floor(id*100.) + froot * .99, // used as material
            total); // depth buffer
    }
    else
    {
        // keep previous result
        fragColor = frame;
    }
    
    // clear between transition
    fragColor *= step(.01, fract(iTime/delay));
}</div>
    
    <div 
    id="Common"
    
    >
// shared constants
const float delay = 15.;
const float max_dist = 200.;

// snippets
#define R iResolution
#define T(uv) texture(iChannel0, uv).a
#define N(x,y,z) normalize(vec3(x,y,z))
#define ss(a,b,t) smoothstep(a,b,t)
#define repeat(p,r) (mod(p,r)-r/2.)
mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }

// Victor Shepardson + Inigo Quilez 
// https://www.shadertoy.com/view/XlXcW4
const uint k = 1103515245U;  // GLIB C
vec3 hash( uvec3 x )
{
    x = ((x>>8U)^x.yzx)*k;
    x = ((x>>8U)^x.yzx)*k;
    x = ((x>>8U)^x.yzx)*k;
    return vec3(x)*(1.0/float(0xffffffffU));
}

// Dave Hoskins
// https://www.shadertoy.com/view/4djSRW
float hash13(vec3 p3)
{
	p3  = fract(p3 * .1031);
    p3 += dot(p3, p3.zyx + 31.32);
    return fract((p3.x + p3.y) * p3.z);
}
vec3 hash31(float p)
{
   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
   p3 += dot(p3, p3.yzx+33.33);
   return fract((p3.xxy+p3.yzz)*p3.zyx); 
}
vec2 hash21(float p)
{
	vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);
}</div>
    
    <div 
    id="Buffer B"
    
    ichannel0="/media/previz/buffer00.png"
    
    ichannel1="/media/previz/buffer01.png"
    
    ichannel2="/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
    
    >
// Frooty by Leon Denise 2023-01-16

// compute ambient occlusion and normal from Buffer A depth

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord/iResolution.xy;
    vec4 color = texture(iChannel0, uv);
    
    // ambient occlusion
    float ao = 0.;
    if (color.a < 20. && color.a > 0.5)
    {
        const float count = 6.;
        for (float f = 0.; f < count; ++f)
        {
            vec3 rng = hash(uvec3(fragCoord, float(iFrame)+196.*f));
            vec2 offset = 20.*pow(rng.z, 4.)*normalize(rng.xy*2.-1.)/R.xy;
            float total = texture(iChannel0, uv+offset).a;
            if (total < 20. && total > 0.5)
                ao += 4.*abs(color.a - total);
        }
    }
    float frame = texture(iChannel1, uv).a;
    fragColor.a = mix(frame, 1.-clamp(ao, 0., 1.), .1);
    
    // normal
    vec3 unit = vec3(1./R.xy, 0);
    float w = T(uv+unit.xz);
    float e = T(uv-unit.xz);
    float n = T(uv+unit.zy);
    float s = T(uv-unit.zy);
    bool edge = w * e * n * s < .001;
    if (color.a > .001 && color.a < max_dist && !edge)
    {
        vec3 normal = normalize(vec3(w-e, n-s, color.r*color.r*.05));
        fragColor.rgb = normal;
    }
    else
    {
        fragColor.rgb = vec3(0,0,1);
    }
}</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Tribal Ornament">
    
    <div 
    id="Image"
    
    ichannel0="/media/previz/buffer00.png"
    
    >
// Tribal Ornament by Leon Denise 2023-01-17

// Buffer A is drawing a circle in motion on a kif
// Image is doing basic lighting and color pattern

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec3 color = vec3(0);
    vec2 uv = fragCoord/iResolution.xy;
    vec3 frame = texture(iChannel0, uv).rgb;
    
    // pattern
    float pattern = sin(frame.r*12.+3.14);
    color = vec3(1) * smoothstep(.0,.5,pattern);
    
    // normal
    #define T(uv) texture(iChannel0, uv).r
    vec3 unit = vec3(1./iResolution.xy, 0);
    vec3 normal = normalize(vec3(T(uv+unit.xz)-T(uv-unit.xz),
                                 T(uv-unit.zy)-T(uv+unit.zy),
                                 frame.r * frame.r));
    
    // light
    color *= dot(normal, normalize(vec3(0,1,1)))*.5+.5;

    fragColor = vec4(color,1.0);
}</div>
    
    <div 
    id="Buffer A"
    
    ichannel0="/media/previz/buffer00.png"
    
    >
// Tribal Ornament by Leon Denise 2023-01-17

// Buffer A is drawing a circle in motion on a kif
// Image is doing basic lighting and color pattern

mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // coordinates
    vec2 uv = fragCoord/iResolution.xy;
    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;
    float lp = length(p);
    
    // angle of rotation
    float t = iTime * 0.5;
    
    // range
    float r = .5 + .2 * sin(lp*1.-iTime);

    // kaleidoscopic iterated function
    float a = 1.;
    const float count = 6.;
    for (float i = 0.; i < count; ++i)
    {
        p.x = abs(p.x)-r*a;
        p *= rot(t/a);
        a /= 1.7;
    }
    
    // shape
    float thin = .04+.02*sin(iTime*4.+lp*10.);
    vec3 color = vec3(smoothstep(thin,.0,length(p)));
    
    // fade 
    vec4 frame = texture(iChannel0, uv);
    color = max(color, frame.rgb - .005);
    
    fragColor = vec4(color,1.0);
}</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Candy Cavern Vomit">
    
    <div 
    id="Image"
    
    ichannel0="/media/previz/buffer00.png"
    
    >
// Candy Cavern Vomit by Leon Denise 2023-01-17

// an authentic rainbow unicorn pukey

// snippets
#define R iResolution
#define N(x,y,z) normalize(vec3(x,y,z))
#define ss(a,b,t) smoothstep(a,b,t)
mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }
float gyroid(vec3 p) { return dot(sin(p), cos(p.yzx)); }
float noise(inout vec3 p)
{
    float result = 0., a = .5;
    for (float i = 0.; i < 3.; ++i, a/=2.)
    {
        p.z += result * .5;
        result += abs(gyroid(p/a)*a);
    }
    return result;
}

// noise pattern
float pattern(vec2 p)
{
    vec3 pos = vec3(p, length(p));
    float n = noise(pos);
    pos = pos*10.;
    pos.y *= .25;
    n = n/2. + noise(pos)/2.;
    n -= .05*sin((pos.y*1.+n*2.+iTime*.5)*10.);
    return n;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec3 color = vec3(0);
    
    // coordinates
    vec2 uv = fragCoord/R.xy;
    vec2 p = (2.*fragCoord-R.xy)/R.y;
    float lp = length(p);

    // act as a "height map"
    float n = pattern(p);

    // normal
    float height = .05;
    float range = 1.;
    vec3 unit = vec3(range/R.xy, 0);
    #define T(uv) pattern(uv)
    vec3 normal = normalize(vec3(T(p+unit.xz)-T(p-unit.xz),
                                 T(p-unit.zy)-T(p+unit.zy),
                                 n * height));
    
    // light
    color += ss(.2,1.,n)*vec3(.5)*pow(dot(normal,N(0,1,.5))*.5+.5, 5.);
    
    // color
    vec3 tint = .5+.5*cos(vec3(1,2,3)*4.9+p.y*2.+n*1.);
    float mask = ss(.0,.4,n-.55);
    color += tint*mask;
    
    // tunnel shade
    color *= ss(-.4,1.,lp);

    fragColor = vec4(color,1.0);
}</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Cavernic">
    
    <div 
    id="Image"
    
    >
// Cavernic by Leon Denise 2023-01-17

// a noise designed cavern with rock and water
// (you can move camera with mouse)

// globals
float material, total;

// snippets
#define R iResolution
#define N(x,y,z) normalize(vec3(x,y,z))
#define ss(a,b,t) smoothstep(a,b,t)
#define repeat(p,r) (mod(p,r)-r/2.)
mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }
float gyroid(vec3 p) { return dot(sin(p), cos(p.yzx)); }

// Victor Shepardson + Inigo Quilez 
// https://www.shadertoy.com/view/XlXcW4
const uint k = 1103515245U;  // GLIB C
vec3 hash( uvec3 x )
{
    x = ((x>>8U)^x.yzx)*k;
    x = ((x>>8U)^x.yzx)*k;
    x = ((x>>8U)^x.yzx)*k;
    return vec3(x)*(1.0/float(0xffffffffU));
}

// Dave Hoskins
// https://www.shadertoy.com/view/4djSRW
float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

// the noises
float noise(inout vec3 p)
{
    float result = 0., a = .5;
    for (float i = 0.; i < 3.; ++i, a/=2.)
    {
        result += (gyroid(p/a)*a);
    }
    return result;
}

float noise2(vec3 p)
{
    float result = 0., a = .5;
    for (float i = 0.; i < 6.; ++i, a/=2.)
    {
        p.z += result * .5;
        result += abs(gyroid(p/a)*a);
    }
    return result;
}

float noise3(vec3 p)
{
    float result = 0., a = .5;
    for (float i = 0.; i < 5.; ++i, a/=2.)
    {
        p.y += result * .5 + iTime * .05;
        result += abs(gyroid(p/a)*a);
    }
    return result;
}

float noise4(vec3 p)
{
    float result = 0., a = .5;
    for (float i = 0.; i < 3.; ++i, a/=2.)
    {
        p.y += result * .5;
        result += abs(gyroid(p/a)*a);
    }
    return result;
}

float map(vec3 p)
{
    float dist = 100.;
    
    // recenter
    p.x += .7;
    
    // travel
    p.z -= iTime * .1;
    
    // save position for later
    vec3 q = p;
    
    // global structure
    p.z *= .5;
    dist = noise(p);
    
    // subtract medium holes
    float grid = .5;
    float shape = length(repeat(p,grid))-grid/1.5;
    shape = max(dist, abs(shape)-.1);
    dist = max(dist, -abs(shape)*.5);
    
    // add intermediate structure
    p = q*5.;
    p.y *= .3;
    dist += abs(noise(p))*.2;
    
    // add medium vertical details
    p = q*10.;
    p.y *= .2;
    dist += pow(abs(noise(p)), 4.)*.1;
    
    // extra medium horizontal details
    p = q;
    p.y += cos(p.z*2.)*.05;
    p.zx *= .3;
    dist -= pow(abs(noise4(p*10.)), 4.)*.03;
    
    // add surface details
    p = q*10.;
    p.z *= 2.;
    dist -= noise2(p) * .05;
    
    // inflate/deflate volume along z
    dist -= .1;
    dist -= .1 * sin(q.z);
    
    // inflate volume for the ceiling
    dist -= max(0., p.y) * .02;
    
    // water
    float water = q.y + 1. + noise3(q*2.) * .01;
    
    material = water < dist ? 1. : 0.;
    dist = min(water, dist);
    
    return dist;
}

// NuSan
// https://www.shadertoy.com/view/3sBGzV
vec3 getNormal(vec3 pos, float e)
{
    vec2 noff = vec2(e,0);
    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));
}

vec3 getColor(vec3 pos, vec3 normal, vec3 ray, float shade)
{
    // Inigo Quilez palette
    // https://iquilezles.org/articles/palettes
    vec3 color = .5+.5*cos(vec3(1,2,3)*5.9+normal.y-normal.z*.5-.5);
    
    // light
    color *= dot(normal, -normalize(pos))*.5+.5;
    
    // shadow
    color *= shade*shade;
    
    return color;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{

    vec3 color = vec3(0);
    
    // coordinates
    vec2 uv = fragCoord/iResolution.xy;
    vec2 p = (2.*fragCoord-R.xy)/R.y;
    vec3 pos = vec3(0,0,0);
    vec3 ray = normalize(vec3(p,-1.));
    vec3 rng = hash(uvec3(fragCoord, 0.));
    
    // mouse camera
    bool clicked = iMouse.x > 0.;
    bool clicking = iMouse.z > 0.;
    if (clicked)
    {
        vec2 mouse = iMouse.xy-abs(iMouse.zw)+R.xy/2.;
        vec2 angle = vec2((2.*mouse-R.xy)/R.y);
        ray.yz *= rot(angle.y);
        ray.xz *= rot(angle.x);
    }

    // raymarch
    total = 0.;
    float shade = 0.;
    for (shade = 1.; shade > 0.; shade -= 1./200.)
    {
        float dist = map(pos);
        if (dist < .001*total || total > 20.) break;
        dist *= 0.12 + 0.05*rng.z;
        pos += ray * dist;
        total += dist;
    }

    // coloring
    if (shade > .01)
    {
        float mat = material;
        vec3 normal = getNormal(pos, .003*total);
        
        // cavern
        if (mat == 0.)
        {
            color = getColor(pos, normal, ray, shade);
            
            // water wet
            float spec = pow(dot(-ray, normal)*.5+.5, 100.);
            color += .2*spec*ss(.5,.0,pos.y+1.);
        }
        // water
        else
        {
            // raymarch reflection
            ray = reflect(ray, normal);
            pos += ray *.05;
            total = 0.;
            for (shade = 1.; shade > 0.; shade -= 1./80.)
            {
                float dist = map(pos);
                if (dist < .05*total || total > 20.) break;
                dist *= 0.2;
                pos += ray * dist;
                total += dist;
            }
            
            // color reflection
            color = getColor(pos, getNormal(pos, .001), ray, shade);
            color *= ss(1.,0.,pos.y+1.);
            color *= ss(0.,0.6,(pos.y+1.2));
        }
    }
    
    fragColor = vec4(color,1.0);
}</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Curling Smoke">
    
    <div 
    id="Image"
    
    ichannel0="/media/previz/buffer00.png"
    
    ichannel1="/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
    
    >
// Curling Smoke by Leon Denise 2023-01-19

// finally learnt how to curl noise

// from Pete Werner article:
// http://petewerner.blogspot.com/2015/02/intro-to-curl-noise.html


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // coordinates
    vec2 uv = fragCoord/iResolution.xy;
    
    // noise
    vec3 blu = texture(iChannel1, fragCoord/1024.).rgb;
    
    // frame
    vec3 color = texture(iChannel0, uv).rgb;
    
    // normal
    vec2 e = vec2(pow(blu.x, 3.)*0.084,0);
    #define T(u) texture(iChannel0, uv+u).r
    vec3 normal = vec3(
        T(e.xy)-T(-e.xy), 
        T(-e.yx)-T(e.yx),
        color.r*.1);
    if (abs(normal.x) + abs(normal.y) + abs(normal.z) > .001)
        normal = normalize(normal);
             
    // shade
    color *= dot(normal, normalize(vec3(0,1,1)))*.5+.5;
    
    fragColor = vec4(color,1.0);
}


</div>
    
    <div 
    id="Buffer A"
    
    ichannel0="/media/previz/buffer00.png"
    
    >
// Curling Smoke

// finally learnt how to curl noise

// from Pete Werner article:
// http://petewerner.blogspot.com/2015/02/intro-to-curl-noise.html

#define R iResolution.xy
float gyroid (vec3 p) { return dot(sin(p),cos(p.yzx)); }
float noise (vec3 p)
{
    float result = 0., a = .5;
    float count = R.y < 500. ? 6. : 8.;
    for (float i = 0.; i < count; ++i, a/=2.)
    {
        p.z += iTime*.1;//+result*.5;
        result += abs(gyroid(p/a))*a;
    }
    return result;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec3 color = vec3(0);
    
    // coordinates
    vec2 uv = fragCoord/R.xy;
    vec2 p = (2.*fragCoord-R.xy)/R.y;
    vec2 offset = vec2(0);
    
    // curl
    vec2 e = vec2(.01,0);
    vec3 pos = vec3(p, length(p)*.5);
    float x = (noise(pos+e.yxy)-noise(pos-e.yxy))/(2.*e.x);
    float y = (noise(pos+e.xyy)-noise(pos-e.xyy))/(2.*e.x);
    vec2 curl = vec2(x,-y);

    // force fields
    offset += curl;
    offset -= normalize(p) * sin(iTime*2.-length(p)*6.);

    // displace buffer sampler coordinates
    uv += offset*.002*vec2(R.y/R.x, 1);
    vec3 frame = texture(iChannel0, uv).rgb;
    
    // spawn from edge
    bool spawn = fragCoord.x < 1. || fragCoord.x > R.x - 1.
        || fragCoord.y < 1. || fragCoord.y > R.y - 1.;
    
    // spawn at first frame
    spawn = spawn || iFrame < 1;
    
    // color palette
    // https://iquilezles.org/articles/palettes
    if (spawn) color = .5+.5*cos(vec3(1,2,3)*5.5+iTime+(uv.x+uv.y)*6.);
    
    // buffer
    else color = max(color, frame);
    
    fragColor = vec4(color,1.0);
}


</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Cloudy Blue Sky">
    
    <div 
    id="Image"
    
    ichannel0="/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
    
    >
// Cloudy Blue Sky
// by Leon Denise
// 05/08/2023

// Guess who is in vacation in the country side.
// Another layers of noise that look like something.
// Trying to push noise patterns farer to create complex shapes with simple code.

// Could be very golfed and textureless,
// but the blue noise scrolling is really adding to the picture,
// and would be hard to golf.


// Gyroid pattern
// Explained by Martijn Steinrucken at:
// https://www.youtube.com/watch?v=b0AayhCO7s8
float gyroid (vec3 p) { return dot(sin(p),cos(p.yzx)); }

// FBM type of noise with gyroid pattern
float noise (vec3 p, float t, float w, float aa)
{
    float result = 0., a = .5;
    for (float i = 0.; i < 4.; ++i, a/=aa)
    {
        p.z += t+result*w; // distortion
        result += abs(gyroid(p/a))*a; // noise pattern
    }
    return result;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec3 color = vec3(0);
    
    // coordinates
    vec2 uv = fragCoord/iResolution.xy;
    vec2 p = 2.*(fragCoord-iResolution.xy/2.)/iResolution.y;
    
    // blue noise scroll
    // by Inigo Quilez from:
    // https://www.shadertoy.com/view/tlySzR
    ivec2 pp = ivec2(fragCoord);
    pp = (pp+(iFrame*196)*ivec2(113,127)) & 1023;
    vec3 blu = texelFetch(iChannel0,pp,0).xyz;
    
    // shape from noise
    vec3 q = vec3(p, 0.);
    float t = iTime*.05-.2/(uv.y); // animation and perspective
    q.y += noise(q*10., -t*4., 0., 1.9)*.1; // small details
    color += noise(q, t, .3, 1.7)*.5-.5; // overall shape
    color += blu.x*0.4; // extra shape reveal with blue noise
    color *= smoothstep(.05,.4,uv.y); // fade out horizon
    
    // color
    vec3 sky = mix(vec3(1), vec3(.4,.8,1), smoothstep(-.4, .4, uv.y));
    color = mix(sky, vec3(1), smoothstep(.0,.2,color.r));
    
    fragColor = vec4(color,1.0);
}</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Colored Bubble Pack">
    
    <div 
    id="Image"
    
    ichannel0="/media/previz/buffer00.png"
    
    >// Colored Bubble Pack
// by Leon Denise
// 05/08/2023

// inspired by stb with his amazing shape packing:
// https://www.shadertoy.com/view/MdGGWt

// this is a very naive understanding and implementation of distance packing
// with a weird fancy light rendering so it feels a bit special

// Buffer A: color pass
// Buffer B: distance packing

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // coordinates
    vec2 uv = fragCoord/R.xy;
    
    // data
    vec4 map = texture(iChannel0, uv);
    float radius = map.y;
    vec2 pos = map.zw;
    
    // shape position
    vec2 p = 2.*(uv-pos)*vec2(R.x/R.y,1);
    float dist = length(p);
    
    // circle shape from distance
    float shape = smoothstep(.0,-.01,dist-radius);
    
    // seed per shape
    vec2 seed = floor(pos*R.xy);
    
    // uv per shape
    uv = (p/radius)*.5+.5;
    
    // color palette
    // by Inigo Quilez at
    // https://iquilezles.org/articles/palettes/
    vec3 tint = .5+.5*cos(vec3(1,2,3)*5.+hash12(seed+196.)*6.+uv.x*1.5);
    tint *= step(hash12(seed),.8);
    
    // normal randomized
    vec3 ray = normalize(vec3(p*2., 1.-dist/radius));
    ray = rndrot(ray, hash42(seed)*2.-1.);
    
    // the cubemap version (you'll have to load the texture)
    //fragColor = vec4(shape*texture(iChannel2, ray).r*tint,1);
    
    float shade = dot(ray, vec3(0,1,0))*.5+.5;
    
    // the tint light version
    //fragColor = vec4(tint*shape*shade,1);
    
    // the weird version
    fragColor = vec4(shape*(mix(tint * pow(1.-shade, 10.), vec3(1), shade)),1);
    
    // the debug viewer
    // fragColor = vec4(p/map.y, shape, 1);
}</div>
    
    <div 
    id="Buffer A"
    
    ichannel0="/media/previz/buffer00.png"
    
    >void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // coordinates
    vec2 uv = fragCoord/R.xy;
    vec2 p = 2.*(fragCoord-R.xy/2.)/R.y;
    
    // random
    float t = float(iFrame)+iDate.x+iDate.y+iDate.z+iDate.w;
    vec2 q = hash21(t);
    
    // position
    p -= (q-.5)*2.*vec2(R.x/R.y,1);
    
    // data
    vec4 map = texture(iChannel0, uv);
    vec4 d = texture(iChannel0, q);
    float radius = d.x;
    
    // distance test
    float dist = length(p)-radius;
    
    // if farer, choose previous result
    if (map.x < dist)
    {
        dist = map.x;
        radius = map.y;
        q = map.zw;
    }
    
    // init and reset
    if (iFrame < 1 || mod(float(iFrame), 60.*40.) < 1.
    
    // resolution changed
    || texture(iChannel0, vec2(0)).xy != iResolution.xy)
    {
        // border distance
        float edge = min(min(abs(uv.y), abs(1.-uv.y)), min(abs(uv.x), abs(1.-uv.x)));
        float maxRadius = .5;
        
        // make it special sometimes
        dist = hash11(t) > .9 ? maxRadius : edge;
        
        // init/reset values
        radius = maxRadius;
        q = vec2(-1);
    }
    
    // serve
    fragColor = vec4(dist,radius,q);
    
    // store resolution so we can reset if it change the next frame
    if (fragCoord.x < 1. && fragCoord.y < 1.)
    {
        fragColor = vec4(iResolution.xy, 0, 0);
    }
}</div>
    
    <div 
    id="Common"
    
    >
#define R iResolution.xy

mat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }

// Dave Hoskins
// https://www.shadertoy.com/view/4djSRW
float hash11(float p)
{
    p = fract(p * .1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}
vec2 hash21(float p)
{
	vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);
}
float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}
vec4 hash42(vec2 p)
{
	vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);
}

// Blackle
// https://suricrasia.online/blog/shader-functions/
vec3 erot(vec3 p, vec3 ax, float ro) {
  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);
}
vec3 rndrot(vec3 p, vec4 rnd)
{
  return erot(p, normalize(tan(rnd.xyz)), rnd.w*acos(-1.));
}</div>
    
  </shadertoy-view>
  
  <shadertoy-view id="Animated Colored Bubble Pack">
    
    <div 
    id="Image"
    
    ichannel0="/media/previz/buffer00.png"
    
    >// Animated Colored Bubble Pack
// by Leon Denise
// 05/08/2023

// variation of Colored Bubble Pack
// https://www.shadertoy.com/view/mtfcDf

// inspired by stb with his amazing shape packing:
// https://www.shadertoy.com/view/MdGGWt

// this is a very naive understanding and implementation of distance packing
// with a weird fancy light rendering so it feels a bit special

// Buffer A: color pass
// Buffer B: distance packing

// update 06/08/2023
// replace step to smoothstep to reduce aliasing

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // coordinates
    vec2 uv = fragCoord/R.xy;
    
    // data
    vec4 map = texture(iChannel0, uv);
    float radius = map.y;
    vec2 pos = map.zw;
    
    // shape position
    vec2 p = 2.*(uv-pos)*vec2(R.x/R.y,1);
    float dist = length(p);
    
    // circle shape from distance
    float shape = smoothstep(.0,-.01,dist-radius);
    
    // seed per shape
    vec2 seed = floor(pos*R.xy);
    
    // uv per shape
    uv = (p/radius)*.5+.5;
    
    // normal and direction
    float z = sqrt(1.-dist/radius);
    vec3 normal = normalize(vec3(p/map.y, z));
    vec3 ray = normal;
    vec3 axis = erot(vec3(0,0,1), vec3(0,1,0), iTime*hash12(seed+196.));
    ray = rndrot(ray, hash42(seed)*2.-1.);
    ray = erot(ray, axis, iTime*hash12(seed)*.5);
    
    float angle = dot(ray, vec3(0,1,0));
    float material = hash12(seed+172.) * 10.;
    vec3 color = vec3(1);

    // strips
    if (material < 1.)
    {
        color = vec3(1) * ss(abs(fract(ray.z*2.+iTime)-.5)-.25, .01/radius);
    }
    // normal axis
    else if (material < 2.)
    {
        color = smoothstep(.0,.01/radius,ray);
    }
    // gradient
    else if (material < 3.)
    {
        color = .5+.5*cos(vec3(1,2,3)*5.+hash12(seed+196.)*6.+ray.y*2.+iTime);
    }
    // gray
    else if (material < 4.)
    {
        color = vec3(angle*.5+.5);
    }
    // dots
    else if (material < 5.)
    {
        vec3 pr = ray*5.+iTime;
        float cell = hash13(floor(pr));
        float black = step(cell,.5);
        float thin = .02/radius;
        float circle = ss(length(fract(pr)-.5)-.5+thin, thin);
        color *= black*circle*radius*3.;
    }
    // normal
    else if (material < 6.)
    {
        color = ray*.5+.5;
    }
    // planet
    else if (material < 7.)
    {
        float x = noise(vec3(ray)*2.+hash42(seed).xyz, 0., 0.5, 2.);
        color = mix(vec3(0,0,1), vec3(0,1,0), ss(x, .05/radius));
        color *= dot(normal, vec3(0,0,1));
    }
    // cross
    else if (material < 8.)
    {
        float size = .1;
        float thin = -.01/radius;
        color *= ss(abs(ray.y)-size, thin)*ss(abs(ray.z)-size, thin)*ss(abs(ray.x)-size, thin);
    }
    // code bar
    else if (material < 9.)
    {
        float lon = atan(ray.z, ray.x);
        float lat = sin(angle+iTime);
        lat = (acos(lat)/3.14)*.5+.5;
        vec2 pl = vec2(lon*.5, lat)*10.;
        float x = hash12(floor(pl));
        float ex = 1.-(2.*abs(fract(pl.x)-.5));
        float ey = 1.-(2.*abs(fract(pl.y)-.5));
        color *= step(.8,x)*smoothstep(.0,.01/radius,ey)*smoothstep(.0,.1/radius,ex);
    }
    // noise
    else
    {
        float x = noise(vec3(ray)+hash42(seed).xyz, iTime*.5, 4.*radius, 2.);
        color *= smoothstep(.2,0.,abs(x));
        color *= dot(normal, vec3(0,0,1))*radius*4.;
    }
    
    // lighting
    angle = dot(normal, normalize(vec3(0,-2,-1)));
    float ratio = (acos(angle)/3.14)*.5+.5;
    color += pow(ratio, 10.)*.5;
    color *= ratio;
    
    fragColor = vec4(shape*color, 1);
}</div>
    
    <div 
    id="Buffer A"
    
    ichannel0="/media/previz/buffer00.png"
    
    >void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // coordinates
    vec2 uv = fragCoord/R.xy;
    vec2 p = 2.*(fragCoord-R.xy/2.)/R.y;
    
    // random
    float t = float(iFrame)+iDate.x+iDate.y+iDate.z+iDate.w;
    vec2 q = hash21(t);
    
    // position
    p -= (q-.5)*2.*vec2(R.x/R.y,1);
    
    // data
    vec4 map = texture(iChannel0, uv);
    vec4 d = texture(iChannel0, q);
    float radius = d.x*.9;
    
    // distance test
    float dist = length(p)-radius;
    
    // if farer, choose previous result
    if (map.x < dist)
    {
        dist = map.x;
        radius = map.y;
        q = map.zw;
    }
    
    // init and reset
    if (iFrame < 1 || mod(float(iFrame), 60.*40.) < 1.
    
    // resolution changed
    || texture(iChannel0, vec2(0)).xy != iResolution.xy)
    {
        // border distance
        float edge = min(min(abs(uv.y), abs(1.-uv.y)), min(abs(uv.x), abs(1.-uv.x)));
        float maxRadius = .5;
        
        // make it special sometimes
        //dist = hash11(t) > .9 ? maxRadius : edge;
        dist = maxRadius;
        
        // init/reset values
        radius = maxRadius;
        q = vec2(-1);
    }
    
    // serve
    fragColor = vec4(dist,radius,q);
    
    // store resolution so we can reset if it change the next frame
    if (fragCoord.x < 1. && fragCoord.y < 1.)
    {
        fragColor = vec4(iResolution.xy, 0, 0);
    }
}</div>
    
    <div 
    id="Common"
    
    >
#define R iResolution.xy
#define ss(x,t) smoothstep(t,.0,x)

mat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }

// Gyroid pattern
// Explained by Martijn Steinrucken at:
// https://www.youtube.com/watch?v=b0AayhCO7s8
float gyroid (vec3 p) { return dot(sin(p),cos(p.yzx)); }

// FBM type of noise with gyroid pattern
float noise (vec3 p, float t, float w, float aa)
{
    float result = 0., a = .5;
    for (float i = 0.; i < 4.; ++i, a/=aa)
    {
        p.z += t+result*w; // distortion
        result += (gyroid(p/a))*a; // noise pattern
    }
    return result;
}

// Dave Hoskins
// https://www.shadertoy.com/view/4djSRW
float hash11(float p)
{
    p = fract(p * .1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}
vec2 hash21(float p)
{
	vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);
}
float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}
vec4 hash42(vec2 p)
{
	vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);
}
float hash13(vec3 p3)
{
	p3  = fract(p3 * .1031);
    p3 += dot(p3, p3.zyx + 31.32);
    return fract((p3.x + p3.y) * p3.z);
}

// Blackle
// https://suricrasia.online/blog/shader-functions/
vec3 erot(vec3 p, vec3 ax, float ro) {
  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);
}
vec3 rndrot(vec3 p, vec4 rnd)
{
  return erot(p, normalize(tan(rnd.xyz)), rnd.w*acos(-1.));
}</div>
    
  </shadertoy-view>
  
</div>

  </body>
</html>